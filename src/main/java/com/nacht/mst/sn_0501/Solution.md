```azure
给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i <= j，且从 0 位开始计算）。

编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。



题目保证从 i 位到 j 位足以容纳 M， 例如： M = 10011，则 i～j 区域至少可容纳 5 位。

 

示例1:

 输入：N = 1024(10000000000), M = 19(10011), i = 2, j = 6
 输出：N = 1100(10001001100)
示例2:

 输入： N = 0, M = 31(11111), i = 0, j = 4
 输出：N = 31(11111)
```
## 解题思路
看题目, 应该是将M基于i进行左移, 然后将N的对应位数先置为0, 然后和左移之后的M做或操作就好了。

将N的对应位数先置为0, 我们可以先基于区间的长度, 构建一个对应长度且全为1的数, 然后左移到对应位置, 做一个非操作, 然后和N做与操作实现。

先试试这个思路ok不...

ac了, 但是我在构造i-j为0, 其他位为1的数的时候, 太丑陋了, 学一下优雅的做法:
```azure
N: 10001010100  i = 2, j = 5, 那我们需要构造的是:
   00001111100
构造过程
1. 先搞个1, 怼到j+1这里  1 << (j + 1)  
00010000000
2. 将其减一, 这样0-j位都是1了 
00001111111
3. 右移i位, 再左移i位, 将多余的1怼掉   (((1 << (j + 1)) - 1) >> i) << i
00001111100
4. 取个非操作  ~ ((((1 << (j + 1)) - 1) >> i) << i)
11110000011

这里有点问题, java如果是j=31的话这个1会丢掉, 我们改成这样:
1. 先搞个1, 怼到j这里  1 << j
00001000000
2. 将其减一, 这样0-j位都是1了 
00000111111
3. 左移一位, 然后+1 (((1 << j) - 1) << 1) + 1
00001111111
3. 右移i位, 再左移i位, 将多余的1怼掉   (((((1 << j) - 1) << 1) + 1) >> i) << i
00001111100
4. 取个非操作  ~ ((((((1 << j) - 1) << 1) + 1) >> i) << i)
11110000011


这样就ok了
```