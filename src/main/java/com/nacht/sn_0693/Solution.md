```azure
给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。

 

示例 1：

输入：n = 5
输出：true
解释：5 的二进制表示是：101
示例 2：

输入：n = 7
输出：false
解释：7 的二进制表示是：111.
示例 3：

输入：n = 11
输出：false
解释：11 的二进制表示是：1011.
 

提示：

1 <= n <= 231 - 1
```
## 解题思路

首先我们分析题目要求的数字的特征, 不难看出, 对于满足条件的正数, 我们将其右移一位之后, 和自身做异或操作, 相当于用每一位和其前一位进行对比, 满足条件的话, 得到的结果肯定每一位都为1。

那么我们怎么验证这个是否都为1呢? 一开始我想到的是, 将其做非操作, 看是否为0, 但是这个结果是不正确的。这个是因为, 对于不满32位的int类型, java会自动在其前面补0, e.g.

```azure
1111
我们以为取非的结果是0000
实际上是
00000000000000000000000000001111
11111111111111111111111111110000
不等于0
```
我们要判断是否全部为1, 应该让其+1, 再和原来的数做与操作, 这样得到的结果为0, 说明原来的数位数全为1。 注意不能用同或, 同或也会有原来的自动补0的问题。
