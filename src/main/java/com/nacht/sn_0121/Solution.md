```azure
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 

提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104
```
## 解题思路
这道题我们的第一印象, 很容易设计出一个复杂度为o(n^2)的算法, 就是在每一个节点查一下它后面的节点, 看当前节点能获得的最大收益是多少, 最后再取最大值。

但是实际上, 我们并不需要知道所有节点的最大收益值。只需要遍历一次, 首先标记第一个节点, 判断后面的元素是大于, 还是小于当前节点, 如果是大于等于当前节点, 只需要继续向后遍历。 直到碰到一个小于当前节点的节点, 我们就记录一下当前节点能获得的最大收益, 以下一个节点为基准继续统计后面的。

这个是基于一个规律: 如果说我们某个节点比前面的节点更大, 那么前面节点买入的收益肯定是比在这个节点买入收益更大的。

举个例子: [2, 3, 1, 4, 5, 6] 对于2来说, 1比它小, 那么对于后面的价格, 在1买入必定比在2买入要好。而对于1前面的节点, 我们也能知道2买入的话, 在3卖出最好。这样, 即使是[2, 13, 1, 4, 5, 6]这种情况, 2买入, 13卖出我们也会统计在里面。

本质上, 就是分割各个上升波段, 然后看各个波段我们能获得的最大收益, 然后取最大的一个。